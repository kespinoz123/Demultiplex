# Assignment the First
Exploratory Commands
Viewing the zipped file
> zcat 1294_S1_L008_R1_001.fastq.gz | less -S
> zcat 1294_S1_L008_R1_001.fastq.gz | head

Checking how big the files are in memory
> ls -lah

How many records per file
> zcat 1294_S1_L008_R1_001.fastq.gz | wc -l AND divide output by 4 = numer of records in FASTQ

How long the read length of each record is
> zcat 1294_S1_L008_R2_001.fastq.gz | head -2 | tail -1 | wc -m (101 bp or 8 bps)

## Part 1
1. Be sure to upload your Python script.

| File name | label | Read length | Phred encoding |
|---|---|---|---|
| 1294_S1_L008_R1_001.fastq.gz | Read 1| 101 | +Phred33 |
| 1294_S1_L008_R2_001.fastq.gz | Index 1| 8 |  +Phred33 |
| 1294_S1_L008_R3_001.fastq.gz | Index 2 | 8 | +Phred33  |
| 1294_S1_L008_R4_001.fastq.gz | Read 2| 101 | +Phred33  |

* R1 and R4 were 102 bp -1 = 101bp. Same logic was applied to R2 and R3. 


2. Per-base NT distribution
    1. Use markdown to insert your 4 histograms here.

Q: What is a good quality score cutoff for index reads and biological read pairs to utilize for sample identification and downstream analysis, respectively? Justify your answer.

After examining the histograms for Read 1 and Read 4 (the 2 biological files), a quality score cut off of 30 would be ideal for identification analysis. The reason being, is that the majority of reads from both R1 and R4 have an average quality score above 30. With this cut off, our data would yield a 99.9% accuracy with a 1/1000 error rate. 

A good cut off quality score for Index 1 and 2 (or R2 and R3) is also 30 for the same reaons explained above. 

Q: How many indexes have undetermined (N) base calls? (Utilize your command line tool knowledge. Submit the command(s) you used. CHALLENGE: use a one-line command)

Number of undertermined N base calls in Index 1/R2: 3976613 and this is only 1.1% of the total  (3976613 / 363246735)*100
Command: zcat /projects/bgmp/shared/2017_sequencing/1294_S1_L008_R2_001.fastq.gz | grep -v "@\|+\|#" | grep -o "N" | wc -l


Number of undertermined N base calls in Index 2/R3: 3329901 and this is only 0.9% of the total
Command: zcat /projects/bgmp/shared/2017_sequencing/1294_S1_L008_R3_001.fastq.gz | grep -v "@\|+\|#" | grep -o "N" | wc -l




## Part 2

-----   DEFINE THE PROBLEM  -----
    Here, we are trying to quality filter the  sequencing reads generated by the 2017 BGMO cohort's Library. More specially, we are trying to determie how many times we observe dual matches, index hopping and unknown index matches. One way to solve this issue, is to sort the sequenced reads into separate files for each given sample, also known as demultiplexing. 
    
-----   DETERMINE/DESCRIBE WHAT OUTPUT WOULD BE INFORMATIVE -----
    Current Files
    #R2 is Index 1 with R1 biological
    #R3 is Index 2 with R4 biological 

Total Number Of Files Expected To Generate: 52 FASTQ Files
48 FASTQ Files Containing Dual Index Matches: 
    > 24 Index Pairs for Read 1
    > 24 Index Pairs For Read 2
        Example: Known indexes such as AAAA match R1 and R2
            AAAA_R1.fq
            AAAA_R2.fq
   
2 FASTQ files containing index hopped reads: known indexes but switched
    > Hop_R1.fq
    > Hop_R2.fq
   
2 FASTQ files for Unknown index reads: non-matching or low quality, containing Ns for undermined base call
    > Unknown_R1.fq
    > Unknown_R2.fq

GRAPHICAL DATA
Import matplotlib and Numpy to plot the following
    Q: How many times was each index found? matched? hopped with another index within these files?
       How do these results differ between Read 1 and Read 
    Generate a table with the following information
        > Number of Dual Index Matches for Read 1/Read 2
        > Number of Hopped Indexes for Read 1/Read 2
        > Number of Unknown Index for Read 1/Read 2

    Histogram displaying the distribution of each of these conditions
        > Frequency of dual index matches for Read 1 and Read 2
        > Frequency of hopped index matches for Read 1 and Read 2
        > Frequency of unknown index matches for Read 1 and Read 2

-----   Write examples (unit tests!)    -----   
Include four properly formatted input FASTQ files with read pairs that cover all three categories (dual matched, index-hopped, unknown index)
Include the appropriate number of properly formatted output FASTQ files given your input files

For the Test Unit Files Submitted, these were the known indexes I made up
* AA
* GG
* TG

Input Test Files: Contain 3 records from each original file
> Test_Input_R1.fq
> Test_Input_R2.fq
> Test_Input_R3.fq
> Test_Input_R4.fq

Output Files
> AA-AA_R1.fq
> AA-AA_R2.fq
> Hop_R1.fq
> Hop_R2.fq
> Unknown_R1.fq
> Unknown_R2.fq

-----   DEVELOP YOUR ALGORITHM USING PSEUDOCODE -----   
Key Words: Record refers to every 4 lines (FASTQ Format)

        1. Open files and go through each record comparing each of their asigned indexes (loops through each record) 
            > 1294_S1_L008_R1_001.fastq.gz
            > 1294_S1_L008_R2_001.fastq.gz
            > 1294_S1_L008_R3_001.fastq.gz
            > 1294_S1_L008_R4_001.fastq.gz

        2. When doing the following conditions, refer back to the file containing the 24 known indexes 
        (Store the 24 known indexes in either a set or dictionary to recall them later on as keys)

            A. IF the first (of 24) Index matches an already known index from the same location = Dual Index Match
                --> Demonstrate that the index read originates from the same cluster/position in the flow cell
                --> A Dual match result will be appended into an output file named after every known index. 
                Ex: AAAA_R1.fq or AAAA_R2.fq
                
            B. IF the index from one read was switched or misassgined to another read = Index Hopped
                --> Index Hopping is a rare event, so all occurences will be added in one file for each read
                --> An index hopped result will be appended into an output file called Hop_R1.fq and Hop_R2.fq
             
            C.  IF the indentified index does NOT match any known indexes (any of the 24 listed) = Unknown Index Match
                * Any undefine index or index of low quality or containing Ns for nucleotides = Unknown *
                --> An Unknown match result will be appended into an output file called Unknown.R1.fq and Unknown.R2.fq
        3. Once all indexes have been finalized from each file, a histogram will be automatically generated to illustrate the distribution of each contion (dual matched/hopped/unknown) for each file.
        4. A Summary table will also be printed for further calculations given the total number of dual matches found, hopped indexes found and unknown indexes for each file. These resuts will be appended into a separate output file called Summary_R1.txt and Summary_R2.txt. 
        

-----   DETERMINE HIGH LEVEL FUNCTIONS  -----   

Reverse Complement Function
DNA = "AAAACCCTTTGGGG"

def reverse_complement(DNA):
    comp = ""
    length = len(DNA)
    for i in range(length):
        base = DNA[length - 1 - i]
        if base=="A":
            comp="T"
        elif base=="T":
            comp="A"
        elif base=="G":
            comp="C"
        elif base=="C":
            comp="G"
        elif base=="N":
            comp="N"
        else:
            print('Input is not a DNA base')
    return DNA[::-1]
print("Reverse Complement:", reverse_complement(DNA))


-----  DESCRIPTION: WHAT DOES THIS FUNCTION DO? -----

This function is needed in order to obtain the complementary nucleotide of the DNA sequence inside each file.
Since DNA is antiparallel, it is important to keep track of the correct orientation from the Forward direction (5' to 3') and Reverse Direction (3' to 5').  


-----  FUNCTION HEADERS (NAME AND PARAMETERS)   -----  
Print Statements (TAB separated)
Table: # Of Dual Matches R1 | # Of Hopped Indexes R1 | Number of Unknown Indexes R1

Table: # Of Dual Matches R2 | # Of Hopped Indexes R2 | Number of Unknown Indexes R2

Saving Generated Graph With Following Titles
    Titles: Distribution of Dual Matches in R1
            Repeated for all conditions and R2
    X = Read length (101 or 8)
    Y = Number of matches/hopping/unknown matches


-----  TEST EXAMPLE FOR FUNCTION: EXAMPLE OF HOW FUNCTION IS SUPPOSED TO WORK   ----- 

Interchanging between the following Nucleotides
    A (Adenosine) = T (Thymine)
    G (Guanine)   = C (Cytosine)

Input: AGGCTA

Output:TAGCCT 
