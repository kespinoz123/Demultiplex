Name: Itzel Espinoza :)

-----   DEFINE THE PROBLEM  -----
    Here, we are trying to quality filter the  sequencing reads generated by the 2017 BGMO cohort's Library. More specially, we are trying to determie how many times we observe dual matches, index hopping and unknown index matches. One way to solve this issue, is to sort the sequenced reads into separate files for each given sample, also known as demultiplexing. 
    
-----   DETERMINE/DESCRIBE WHAT OUTPUT WOULD BE INFORMATIVE -----
    Current Files
    #R2 is Index 1 with R1 biological
    #R3 is Index 2 with R4 biological 

Total Number Of Files Expected To Generate: 52 FASTQ Files
48 FASTQ Files Containing Dual Index Matches: 
    > 24 Index Pairs for Read 1
    > 24 Index Pairs For Read 2
        Example: Known indexes such as AAAA match R1 and R2
            AAAA_R1.fq
            AAAA_R2.fq
   
2 FASTQ files containing index hopped reads: known indexes but switched
    > Hop_R1.fq
    > Hop_R2.fq
   
2 FASTQ files for Unknown index reads: non-matching or low quality, containing Ns for undermined base call
    > Unknown_R1.fq
    > Unknown_R2.fq

GRAPHICAL DATA
Import matplotlib and Numpy to plot the following
    Q: How many times was each index found? matched? hopped with another index within these files?
       How do these results differ between Read 1 and Read 
    Generate a table with the following information
        > Number of Dual Index Matches for Read 1/Read 2
        > Number of Hopped Indexes for Read 1/Read 2
        > Number of Unknown Index for Read 1/Read 2

    Histogram displaying the distribution of each of these conditions
        > Frequency of dual index matches for Read 1 and Read 2
        > Frequency of hopped index matches for Read 1 and Read 2
        > Frequency of unknown index matches for Read 1 and Read 2

-----   Write examples (unit tests!)    -----   
Include four properly formatted input FASTQ files with read pairs that cover all three categories (dual matched, index-hopped, unknown index)
Include the appropriate number of properly formatted output FASTQ files given your input files

For the Test Unit Files Submitted, these were the known indexes I made up
* AA
* GG
* TG

Input Test Files: Contain 3 records from each original file
> Test_Input_R1.fq
> Test_Input_R2.fq
> Test_Input_R3.fq
> Test_Input_R4.fq

Output Files
> AA-AA_R1.fq
> AA-AA_R2.fq
> Hop_R1.fq
> Hop_R2.fq
> Unknown_R1.fq
> Unknown_R2.fq

-----   DEVELOP YOUR ALGORITHM USING PSEUDOCODE -----   
Key Words: Record refers to every 4 lines (FASTQ Format)

        1. Open files and go through each record comparing each of their asigned indexes (loops through each record) 
            > 1294_S1_L008_R1_001.fastq.gz
            > 1294_S1_L008_R2_001.fastq.gz
            > 1294_S1_L008_R3_001.fastq.gz
            > 1294_S1_L008_R4_001.fastq.gz

        2. When doing the following conditions, refer back to the file containing the 24 known indexes 
        (Store the 24 known indexes in either a set or dictionary to recall them later on as keys)

            A. IF the first (of 24) Index matches an already known index from the same location = Dual Index Match
                --> Demonstrate that the index read originates from the same cluster/position in the flow cell
                --> A Dual match result will be appended into an output file named after every known index. 
                Ex: AAAA_R1.fq or AAAA_R2.fq
                
            B. IF the index from one read was switched or misassgined to another read = Index Hopped
                --> Index Hopping is a rare event, so all occurences will be added in one file for each read
                --> An index hopped result will be appended into an output file called Hop_R1.fq and Hop_R2.fq
             
            C.  IF the indentified index does NOT match any known indexes (any of the 24 listed) = Unknown Index Match
                * Any undefine index or index of low quality or containing Ns for nucleotides = Unknown *
                --> An Unknown match result will be appended into an output file called Unknown.R1.fq and Unknown.R2.fq
        3. Once all indexes have been finalized from each file, a histogram will be automatically generated to illustrate the distribution of each contion (dual matched/hopped/unknown) for each file.
        4. A Summary table will also be printed for further calculations given the total number of dual matches found, hopped indexes found and unknown indexes for each file. These resuts will be appended into a separate output file called Summary_R1.txt and Summary_R2.txt. 
        

-----   DETERMINE HIGH LEVEL FUNCTIONS  -----   

Reverse Complement Function
DNA = "AAAACCCTTTGGGG"

def reverse_complement(DNA):
    comp = ""
    length = len(DNA)
    for i in range(length):
        base = DNA[length - 1 - i]
        if base=="A":
            comp="T"
        elif base=="T":
            comp="A"
        elif base=="G":
            comp="C"
        elif base=="C":
            comp="G"
        elif base=="N":
            comp="N"
        else:
            print('Input is not a DNA base')
    return DNA[::-1]
    # reverse_complement = reverse_complement[::-1]
print("Reverse Complement:", reverse_complement(DNA))


-----  DESCRIPTION: WHAT DOES THIS FUNCTION DO? -----

This function is needed in order to obtain the complementary nucleotide of the DNA sequence inside each file.
Since DNA is antiparallel, it is important to keep track of the correct orientation from the Forward direction (5' to 3') and Reverse Direction (3' to 5').  


-----  FUNCTION HEADERS (NAME AND PARAMETERS)   -----  
Print Statements (TAB separated)
Table: # Of Dual Matches R1 | # Of Hopped Indexes R1 | Number of Unknown Indexes R1

Table: # Of Dual Matches R2 | # Of Hopped Indexes R2 | Number of Unknown Indexes R2

Saving Generated Graph With Following Titles
    Titles: Distribution of Dual Matches in R1
            Repeated for all conditions and R2
    X = Read length (101 or 8)
    Y = Number of matches/hopping/unknown matches


-----  TEST EXAMPLE FOR FUNCTION: EXAMPLE OF HOW FUNCTION IS SUPPOSED TO WORK   ----- 

Interchanging between the following Nucleotides
    A (Adenosine) = T (Thymine)
    G (Guanine)   = C (Cytosine)

Input: AGGCTA

Output:TAGCCT 